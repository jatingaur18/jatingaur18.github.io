<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jatin Gaur | Board Feed</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        display: ['Space Grotesk', 'sans-serif'],
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        chess: {
                            bg: '#161512',      // Lichess-style dark background
                            card: '#262421',    // Slightly lighter card
                            light: '#babebb',   // Text gray
                            white: '#ffffff',
                            accent: '#769656',  // Standard Tournament Board Green
                            accentHover: '#5d7a42',
                            danger: '#ca3431'   // Red for "busy" etc
                        }
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #161512;
            color: #babebb;
            /* Subtle checkered texture from Bento Theme */
            background-image:
                linear-gradient(45deg, #1a1916 25%, transparent 25%),
                linear-gradient(-45deg, #1a1916 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #1a1916 75%),
                linear-gradient(-45deg, transparent 75%, #1a1916 75%);
            background-size: 40px 40px;
            background-position: 0 0, 0 20px, 20px -20px, -20px 0px;
            min-height: 100vh;
        }

        /* --- Masonry Layout --- */
        #pin-container {
            column-count: 5;
            column-gap: 20px;
            margin: 0 auto;
            max-width: 1400px;
        }

        /* --- Bento Card Styling for Pins --- */
        .pin {
            background-color: #262421;
            border-radius: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-bottom: 20px;
            break-inside: avoid;
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
        }

        .pin:hover {
            transform: translateY(-4px);
            border-color: #769656;
            /* Chess Accent Green */
            box-shadow: 0 10px 30px -10px rgba(0, 0, 0, 0.5);
        }

        .pin img {
            width: 100%;
            height: auto;
            display: block;
            transition: transform 0.5s ease, filter 0.3s ease;
            filter: brightness(0.9);
        }

        .pin:hover img {
            transform: scale(1.02);
            filter: brightness(1.05);
        }

        /* --- Loading State --- */
        .loading::after {
            content: '';
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #333;
            border-top: 2px solid #769656;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* --- Responsive Columns --- */
        @media (max-width: 1200px) {
            #pin-container {
                column-count: 4;
            }
        }

        @media (max-width: 992px) {
            #pin-container {
                column-count: 3;
            }
        }

        @media (max-width: 768px) {
            #pin-container {
                column-count: 2;
            }
        }

        @media (max-width: 480px) {
            #pin-container {
                column-count: 1;
            }
        }

        /* --- Scrollbar --- */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #161512;
        }

        ::-webkit-scrollbar-thumb {
            background: #3c3a36;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #769656;
        }
    </style>
</head>

<body class="font-sans">

    <!-- Header -->
    <header class="py-8 text-center border-b border-white/5 bg-[#161512]/90 backdrop-blur-sm sticky top-0 z-50">
        <h1 class="text-3xl font-display font-bold text-chess-white mb-2">Feed</h1>
        <div
            class="inline-flex items-center gap-2 px-3 py-1 bg-[#262421] rounded-full border border-white/5 text-sm text-chess-light">
            <i class="fa-brands fa-pinterest text-chess-accent"></i>
            <span>Board: <span id="board-name" class="font-mono text-chess-accent font-bold"></span></span>
        </div>
    </header>

    <!-- Main Content -->
    <main class="py-8 px-4">
        <div id="status-message" class="text-center py-12 text-gray-500 font-mono text-sm loading">Initializing Feed...
        </div>
        <div id="pin-container"></div>
    </main>

    <!-- Animation Section (Interactive Pixel Shooter) -->
    <section class="relative h-[320px] overflow-hidden border-t border-white/5 bg-[#161512]">
        <!-- Gradient Overlay -->
        <div
            class="absolute top-0 left-0 w-full h-10 bg-gradient-to-b from-[#161512] to-transparent z-10 pointer-events-none">
        </div>

        <!-- Hint -->
        <div class="absolute bottom-4 right-4 z-20 text-xs font-mono text-chess-accent opacity-50 pointer-events-none">
            CLICK TO SHOOT THE PIXELS
        </div>

        <canvas id="canvas" class="w-full h-full block cursor-crosshair"></canvas>
    </section>

    <footer class="bg-[#0c0c0a] py-6 text-center border-t border-white/5">
        <p class="text-xs text-gray-600">&copy; 2024 Jatin Gaur. All rights reserved.</p>
    </footer>

    <script>
        // --- 1. PINTEREST FETCH LOGIC ---
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const boardPath = urlParams.get('board') || 'mad'; // Default board

            document.getElementById('board-name').textContent = boardPath;
            fetchPins(boardPath);
        });

        async function fetchPins(boardPath) {
            const pinContainer = document.getElementById('pin-container');
            const statusMessage = document.getElementById('status-message');
            statusMessage.innerHTML = 'Connecting to Pinterest...';

            // Using a CORS proxy to fetch the RSS feed
            const rssUrl = `https://www.pinterest.com/jatingaur2512/${boardPath}.rss`;
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(rssUrl)}`;

            try {
                const response = await fetch(proxyUrl);
                if (!response.ok) throw new Error('Network response was not ok');

                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'application/xml');
                const items = xmlDoc.querySelectorAll('item');

                if (items.length === 0) {
                    statusMessage.textContent = 'No pins found. Board may be private.';
                    statusMessage.classList.remove('loading');
                    return;
                }

                statusMessage.style.display = 'none';

                items.forEach((item, index) => {
                    const description = item.querySelector('description').textContent;
                    // Extract image URL from CDATA/description HTML
                    const match = description.match(/https?:\/\/i\.pinimg\.com\/[^"]+/);

                    if (match) {
                        const imageUrl = match[0];
                        // Try to get higher res
                        const highQualityUrl = imageUrl.replace(/\/\d+x\//, '/originals/');

                        const pinDiv = document.createElement('div');
                        pinDiv.className = 'pin group';
                        pinDiv.style.opacity = '0';
                        pinDiv.style.transform = 'translateY(20px)';

                        // Link wrapper
                        const link = document.createElement('a');
                        link.href = item.querySelector('link').textContent;
                        link.target = "_blank";

                        const pinImage = document.createElement('img');
                        pinImage.src = highQualityUrl;
                        pinImage.alt = item.querySelector('title')?.textContent || 'Pin';

                        link.appendChild(pinImage);
                        pinDiv.appendChild(link);

                        // Optional: Add simple caption overlay
                        const title = item.querySelector('title')?.textContent;
                        if (title && title !== ' ') {
                            const caption = document.createElement('div');
                            caption.className = 'absolute bottom-0 left-0 w-full p-2 bg-gradient-to-t from-black/90 to-transparent text-white text-xs opacity-0 group-hover:opacity-100 transition-opacity duration-300 font-sans';
                            caption.textContent = title;
                            link.appendChild(caption);
                        }

                        pinImage.onload = () => {
                            setTimeout(() => {
                                pinDiv.style.opacity = '1';
                                pinDiv.style.transform = 'translateY(0)';
                            }, index * 50);
                        };

                        pinContainer.appendChild(pinDiv);
                    }
                });

            } catch (error) {
                console.error('Fetch error:', error);
                statusMessage.innerHTML = `
                    <div class="text-chess-danger mb-2"><i class="fa-solid fa-triangle-exclamation"></i> Unable to load pins</div>
                    <div class="text-xs text-gray-600">This often happens due to CORS restrictions when opening files directly (file://) or in sandboxed previews.</div>
                    <div class="text-xs text-gray-600 mt-2">Try running this on a local web server (e.g., Live Server).</div>
                `;
                statusMessage.classList.remove('loading');
            }
        }

        // --- 2. PIXEL SHOOTING GAME (Replaces GSAP Animation) ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let gameFrame = 0;

        // Game State
        const targets = [];
        const particles = [];

        // Colors
        const CHESS_ACCENT = '#769656';
        const CHESS_ACCENT_HOVER = '#5d7a42';
        const CHESS_WHITE = '#e1e1e1';

        function resize() {
            width = canvas.width = canvas.offsetWidth;
            height = canvas.height = canvas.offsetHeight;
        }
        window.addEventListener('resize', resize);

        // --- DRAWING UTILS ---
        function drawPixelMan(x, y, frame, color) {
            ctx.fillStyle = color;
            const s = 3; // Scale size
            const isStep = Math.floor(frame / 10) % 2 === 0;

            // Draw simple pixel man structure
            // Head
            ctx.fillRect(x + 2 * s, y, 4 * s, 4 * s);
            // Body
            ctx.fillRect(x + 2 * s, y + 5 * s, 4 * s, 6 * s);
            // Arms
            if (isStep) {
                ctx.fillRect(x, y + 5 * s, 2 * s, 5 * s);
                ctx.fillRect(x + 6 * s, y + 5 * s, 2 * s, 5 * s);
            } else {
                ctx.fillRect(x + 1 * s, y + 5 * s, 2 * s, 5 * s);
                ctx.fillRect(x + 5 * s, y + 5 * s, 2 * s, 5 * s);
            }
            // Legs
            if (isStep) {
                ctx.fillRect(x + 2 * s, y + 11 * s, 2 * s, 5 * s);
                ctx.fillRect(x + 4 * s, y + 11 * s, 2 * s, 5 * s);
            } else {
                ctx.fillRect(x, y + 11 * s, 2 * s, 4 * s);
                ctx.fillRect(x + 6 * s, y + 11 * s, 2 * s, 4 * s);
            }

            return { w: 8 * s, h: 16 * s }; // Approx bounds
        }

        // --- CLASSES ---
        class Target {
            constructor() {
                this.x = Math.random() * (width - 24);
                this.y = Math.random() * (height - 48);
                this.speedX = (Math.random() - 0.5) * 2;
                this.speedY = (Math.random() - 0.5) * 2;
                this.color = Math.random() > 0.5 ? CHESS_ACCENT : CHESS_WHITE;
                this.frameOffset = Math.floor(Math.random() * 100);
                // Approximate size for collision
                this.width = 24;
                this.height = 48;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                // Bounce off edges
                if (this.x < 0 || this.x > width - this.width) this.speedX *= -1;
                if (this.y < 0 || this.y > height - this.height) this.speedY *= -1;
            }
            draw() {
                // Bobbing animation
                const bob = (Math.floor((gameFrame + this.frameOffset) / 10) % 2 === 0) ? 0 : -2;
                drawPixelMan(this.x, this.y + bob, gameFrame + this.frameOffset, this.color);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 4 + 2;
                this.speedX = (Math.random() - 0.5) * 6;
                this.speedY = (Math.random() - 0.5) * 6;
                this.color = color;
                this.life = 100;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life -= 2;
                this.size *= 0.95;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / 100;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        // --- GAME LOOP ---
        function initGame() {
            // Spawn initial dudes
            for (let i = 0; i < 8; i++) {
                targets.push(new Target());
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);

            // Draw Targets
            targets.forEach(t => {
                t.update();
                t.draw();
            });

            // Draw Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            gameFrame++;
            requestAnimationFrame(animate);
        }

        // --- INTERACTION ---
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Check collisions
            for (let i = targets.length - 1; i >= 0; i--) {
                const t = targets[i];
                // Simple AABB collision
                if (mouseX >= t.x - 10 && mouseX <= t.x + t.width + 10 &&
                    mouseY >= t.y - 10 && mouseY <= t.y + t.height + 10) {

                    // Explode!
                    for (let j = 0; j < 12; j++) {
                        particles.push(new Particle(t.x + t.width / 2, t.y + t.height / 2, t.color));
                    }

                    // Remove target
                    targets.splice(i, 1);

                    // Respawn after delay
                    setTimeout(() => targets.push(new Target()), 800 + Math.random() * 1000);
                }
            }
        });

        // Initialize
        resize();
        initGame();
        animate();

    </script>
</body>

</html>