<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinterest Board Feed</title>
    <style>
        /* --- Ultra-Dark Professional Theme --- */

        /* --- Base Setup --- */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
            margin: 0;
            background-color: #000000; /* Pure Black */
            color: #e0e0e0; /* Soft Gray */
            line-height: 1.5;
            min-height: 100vh;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(24, 24, 24, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(24, 24, 24, 0.3) 0%, transparent 50%);
        }

        /* --- Minimal Header --- */
        header {
            background-color: #0a0a0a;
            padding: 12px 20px;
            text-align: center;
            border-bottom: 1px solid #1a1a1a;
            position: relative;
        }

        header h1 {
            margin: 0;
            font-size: 1.4em;
            font-weight: 500;
            color: #e0e0e0;
            letter-spacing: -0.01em;
        }

        header p {
            margin: 4px 0 0;
            color: #666666;
            font-size: 0.85em;
            font-weight: 400;
        }

        #board-name {
            font-weight: 500;
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            background-color: #111111;
            padding: 4px 8px;
            border-radius: 4px;
            color: #e0e0e0;
            border: 1px solid #222222;
            display: inline-block;
            font-size: 0.9em;
        }

        /* --- Enhanced Masonry Grid --- */
        #pin-container {
            margin: 30px auto;
            padding: 0 20px;
            max-width: 1400px;
            column-count: 5;
            column-gap: 20px;
        }

        /* --- Professional Pin Cards with Glow Effects --- */
        .pin {
            margin-bottom: 20px;
            break-inside: avoid;
            overflow: hidden;
            border-radius: 12px;
            background: linear-gradient(145deg, #0a0a0a 0%, #111111 50%, #0a0a0a 100%);
            border: 1px solid #1a1a1a;
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.02);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
        }

        .pin::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 12px;
            padding: 1px;
            background: linear-gradient(145deg, 
                rgba(255, 255, 255, 0.03) 0%, 
                transparent 50%, 
                rgba(255, 255, 255, 0.01) 100%);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: xor;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .pin:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.6),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.03);
            border-color: #222222;
        }

        .pin:hover::before {
            opacity: 1;
        }

        .pin img {
            width: 100%;
            height: auto;
            display: block;
            transition: all 0.4s ease;
            filter: brightness(0.95) contrast(1.05);
        }

        .pin:hover img {
            filter: brightness(1) contrast(1.1);
        }
        
        /* --- Status Messages with Glow --- */
        #status-message {
            text-align: center;
            font-size: 1.1em;
            padding: 60px 20px;
            color: #666666;
            font-weight: 400;
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.02) 0%, transparent 70%);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
        }

        /* --- Loading Animation --- */
        .loading {
            position: relative;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #333333;
            border-top: 2px solid #666666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Glow Effects --- */
        @keyframes subtleGlow {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.02); }
            50% { box-shadow: 0 0 15px rgba(255, 255, 255, 0.04); }
        }

        /* --- Enhanced Responsive Design --- */
        @media (max-width: 1400px) {
            #pin-container { column-count: 4; max-width: 1200px; }
        }
        @media (max-width: 1200px) {
            #pin-container { column-count: 4; max-width: 1000px; }
        }
        @media (max-width: 992px) {
            #pin-container { column-count: 3; max-width: 800px; }
            header h1 { font-size: 1.6em; }
        }
        @media (max-width: 768px) {
            #pin-container { column-count: 2; padding: 0 15px; }
            header { padding: 20px 15px; }
            header h1 { font-size: 1.5em; }
        }
        @media (max-width: 480px) {
            #pin-container { column-count: 1; }
            header { padding: 18px 12px; }
            header h1 { font-size: 1.4em; }
            #board-name { font-size: 0.9em; }
        }

        /* --- Scrollbar Styling --- */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0a0a0a;
        }
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #333333 0%, #222222 100%);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #444444 0%, #333333 100%);
        }

        /* --- Selection Styling --- */
        ::selection {
            background-color: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }

        footer {
            background: #050505;
            padding: 2rem 0;
            text-align: center;
            border-top: 1px solid #1a1a1a;
        }
    </style>
</head>
<body>

    <header>
        <h1>Pinterest Board Feed</h1>
        <p>Displaying board: <span id="board-name"></span></p>
    </header>

    <main>
        <div id="status-message" class="loading">Initializing Feed</div>
        <div id="pin-container"></div>
    </main>

    <section style="position: relative; height: 320px; overflow: hidden; background: #050505; border-top: 1px solid #1a1a1a;">
        <canvas id="canvas" style="width: 100%; height: 100%; display: block;"></canvas>
    </section>

    <footer>
        <div class="container">
            <p>&copy; 2024 Jatin Gaur. All rights reserved.</p>
        </div>
    </footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const boardPath = urlParams.get('board') || 'mad'; // Default board

            document.getElementById('board-name').textContent = boardPath;
            fetchPins(boardPath);
        });

        async function fetchPins(boardPath) {
            const pinContainer = document.getElementById('pin-container');
            const statusMessage = document.getElementById('status-message');
            statusMessage.textContent = 'Fetching pins';
            statusMessage.classList.add('loading');
            
            const rssUrl = `https://www.pinterest.com/jatingaur2512/${boardPath}.rss`;
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(rssUrl)}`;
            
            try {
                const response = await fetch(proxyUrl);
                if (!response.ok) {
                    throw new Error(`Network response was not ok: ${response.statusText}`);
                }
                const xmlText = await response.text();
                
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'application/xml');
                
                const items = xmlDoc.querySelectorAll('item');
                
                if (items.length === 0) {
                    statusMessage.textContent = 'No pins found. Board may be private or does not exist.';
                    statusMessage.classList.remove('loading');
                    return;
                }
                
                statusMessage.style.display = 'none';

                // Add staggered animation for pin loading
                items.forEach((item, index) => {
                    const description = item.querySelector('description').textContent;
                    const match = description.match(/https?:\/\/i\.pinimg\.com\/[^"]+/);
                    
                    if (match) {
                        const imageUrl = match[0];
                        const highQualityUrl = imageUrl.replace(/\/\d+x\//, '/originals/');
                        
                        const pinDiv = document.createElement('div');
                        pinDiv.className = 'pin';
                        pinDiv.style.opacity = '0';
                        pinDiv.style.transform = 'translateY(20px)';
                        
                        const pinImage = document.createElement('img');
                        pinImage.src = highQualityUrl; 
                        pinImage.alt = item.querySelector('title').textContent;
                        
                        // Enhanced image loading with fade-in effect
                        pinImage.onload = () => {
                            setTimeout(() => {
                                pinDiv.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                                pinDiv.style.opacity = '1';
                                pinDiv.style.transform = 'translateY(0)';
                            }, index * 50); // Staggered loading
                        };
                        
                        pinDiv.appendChild(pinImage);
                        pinContainer.appendChild(pinDiv);
                    }
                });

            } catch (error) {
                console.error('Failed to fetch pins:', error);
                statusMessage.textContent = 'Error loading pins. Please check the board name and your network connection.';
                statusMessage.classList.remove('loading');
            }
        }

        
        const config = {
          src: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/175711/open-peeps-sheet.png',
          rows: 15,
          cols: 7
        }

        // UTILS
        const randomRange = (min, max) => min + Math.random() * (max - min)
        const randomIndex = (array) => randomRange(0, array.length) | 0
        const removeFromArray = (array, i) => array.splice(i, 1)[0]
        const removeItemFromArray = (array, item) => removeFromArray(array, array.indexOf(item))
        const removeRandomFromArray = (array) => removeFromArray(array, randomIndex(array))
        const getRandomFromArray = (array) => (array[randomIndex(array) | 0])

        // TWEEN FACTORIES
        const resetPeep = ({ stage, peep }) => {
          const direction = Math.random() > 0.5 ? 1 : -1
          // Reduced the offsetY calculation to keep people more visible
          const offsetY = 50 - 100 * gsap.parseEase('power2.in')(Math.random())
          const startY = stage.height - peep.height + offsetY
          let startX
          let endX
          
          if (direction === 1) {
            startX = -peep.width
            endX = stage.width
            peep.scaleX = 1
          } else {
            startX = stage.width + peep.width
            endX = 0
            peep.scaleX = -1
          }
          
          peep.x = startX
          peep.y = startY
          peep.anchorY = startY
          
          return { startX, startY, endX }
        }

        const normalWalk = ({ peep, props }) => {
          const { startX, startY, endX } = props
          const xDuration = 10
          const yDuration = 0.25
          
          const tl = gsap.timeline()
          tl.timeScale(randomRange(0.5, 1.5))
          tl.to(peep, { duration: xDuration, x: endX, ease: 'none' }, 0)
          tl.to(peep, { duration: yDuration, repeat: xDuration / yDuration, yoyo: true, y: startY - 10 }, 0)
            
          return tl
        }

        const walks = [normalWalk]

        // CLASSES
        class Peep {
          constructor({ image, rect }) {
            this.image = image
            this.setRect(rect)
            this.x = 0
            this.y = 0
            this.anchorY = 0
            this.scaleX = 1
            this.walk = null
          }
          
          setRect (rect) {
            this.rect = rect
            this.width = rect[2]
            this.height = rect[3]
            this.drawArgs = [this.image, ...rect, 0, 0, this.width, this.height]
          }
          
          render (ctx) {
            ctx.save()
            ctx.translate(this.x, this.y)
            ctx.scale(this.scaleX, 1)
            ctx.drawImage(...this.drawArgs)
            ctx.restore()
          }
        }

        // MAIN
        const img = document.createElement('img')
        const canvas = document.querySelector('#canvas')
        const ctx = canvas.getContext('2d')

        const stage = { width: 0, height: 0 }
        const allPeeps = []
        const availablePeeps = []
        const crowd = []

        function initPeopleAnimation() {
          createPeeps()
          resize()
          gsap.ticker.add(render)
          window.addEventListener('resize', resize)
        }

        function createPeeps () {
          const { rows, cols } = config
          const { naturalWidth: width, naturalHeight: height } = img
          const total = rows * cols
          const rectWidth = width / rows
          const rectHeight = height / cols
          
          for (let i = 0; i < total; i++) {
            allPeeps.push(new Peep({
              image: img,
              rect: [(i % rows) * rectWidth, (i / rows | 0) * rectHeight, rectWidth, rectHeight]
            }))
          }
        }

        function resize () {
          stage.width = canvas.clientWidth
          stage.height = canvas.clientHeight
          canvas.width = stage.width * devicePixelRatio
          canvas.height = stage.height * devicePixelRatio
          
          crowd.forEach((peep) => { peep.walk.kill() })
          crowd.length = 0
          availablePeeps.length = 0
          availablePeeps.push(...allPeeps)
          initCrowd()
        }

        function initCrowd () {
          while (availablePeeps.length) {
            addPeepToCrowd().walk.progress(Math.random())
          }
        }

        function addPeepToCrowd () {
          const peep = removeRandomFromArray(availablePeeps)
          const walk = getRandomFromArray(walks)({
            peep,
            props: resetPeep({ peep, stage })
          }).eventCallback('onComplete', () => {
            removePeepFromCrowd(peep)
            addPeepToCrowd()
          })
          
          peep.walk = walk
          crowd.push(peep)
          crowd.sort((a, b) => a.anchorY - b.anchorY)
          return peep
        }

        function removePeepFromCrowd (peep) {
          removeItemFromArray(crowd, peep)
          availablePeeps.push(peep)
        }

        function render () {
          canvas.width = canvas.width
          ctx.save()
          ctx.scale(devicePixelRatio, devicePixelRatio)
          crowd.forEach((peep) => { peep.render(ctx) })
          ctx.restore()
        }

        // Initialize animation after image loads
        img.onload = initPeopleAnimation
        img.src = config.src
    </script>

</body>
</html>